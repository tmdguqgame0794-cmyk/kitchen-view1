<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>홀 · 지금 나갈 테이블 + 인원수(인원>0 노란색)</title>
<style>
:root{
  --bg:#0b1220;--panel:#0f172a;--ink:#e5e7eb;--muted:#94a3b8;--line:#2b3444;
  --y:rgba(253,230,138,.18);
  /* manage와 동일 상태색 */
  --c-blue:rgba(37,99,235,.18);
  --c-gray:rgba(203,205,211,.22);
  --c-red:rgba(220,38,38,.20);
  --c-green:rgba(22,163,74,.20);
  --c-yellow:rgba(253,230,138,.18);
  --c-orange:rgba(234,88,12,.22);
  --c-pink:rgba(219,39,119,.22);
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Helvetica,Arial,sans-serif}
.wrap{max-width:1024px;margin:0 auto;padding:14px}
h1{margin:8px 0 10px;font-size:clamp(18px,2.6vh,28px)}
.card{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:12px}
.section{margin-top:12px}
.small{color:var(--muted);font-size:12px}

/* 3x3 그리드(메뉴 6 + 음료 3) */
.grid33{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.tile{
  border:1px solid var(--line);border-radius:12px;background:#0b1324;
  padding:14px;cursor:pointer;display:flex;flex-direction:column;gap:6px;min-height:88px
}
.tile:active{transform:scale(.99)}
.tile .name{font-weight:1000;font-size:clamp(16px,2.2vh,22px);line-height:1.15}
.tile .next{font-size:clamp(22px,3.2vh,30px);font-weight:1000}
.tile .hint{font-size:11px;color:var(--muted)}
.tile.disabled{opacity:.5;cursor:not-allowed}

/* 인원 그리드(축소) */
.gridP{display:grid;grid-template-columns:repeat(6,1fr);gap:6px;margin-top:8px}
.cell{background:#0b1324;border:1px solid var(--line);border-radius:10px;padding:8px 10px;display:flex;align-items:center;justify-content:space-between;min-height:42px}
.cell .t{font-weight:800;font-size:12px}
.cell .p{font-weight:1000;font-size:16px;color:#e5e7eb}

/* 상태색 (manage 동일 클래스명) */
.row-yellow{background:var(--c-yellow)}
.row-blue  {background:var(--c-blue)}
.row-gray  {background:var(--c-gray)}
.row-red   {background:var(--c-red)}
.row-green {background:var(--c-green)}
.row-orange{background:var(--c-orange)}
.row-pink  {background:var(--c-pink)}
</style>
</head>
<body>
<div class="wrap">
  <h1>홀 · 지금 나갈 테이블 (탭하여 서빙 처리)</h1>
  <div class="card">
    <div id="grid33" class="grid33"></div>
  </div>
  <div class="small">규칙: 아직 한 접시도 안 나간 테이블을 주문순 기준 먼저, 이후엔 주문순 그대로.</div>

  <h1 class="section">홀 · 인원 현황</h1>
  <div class="card">
    <div id="pgrid" class="gridP"></div>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script>
(function(){
  const CONFIG={
    menus:["우삼겹숙주볶음","치즈김치전","만두계란탕","불닭콘치즈","치즈콘계란말이","두부김치"],
    tables:24,
    ROOM:"CHOOKJAE"
  };
  const firebaseConfig={
    apiKey:"AIzaSyCWBPv3YgGKOH0b1e59I3QG9SfRtcNZSDY",
    authDomain:"chookjae-8e133.firebaseapp.com",
    projectId:"chookjae-8e133",
    storageBucket:"chookjae-8e133.firebasestorage.app",
    messagingSenderId:"82575498649",
    appId:"1:82575498649:web:364e9c286a9f3ae7474708",
    measurementId:"G-BQ95TPG37V",
    databaseURL:"https://chookjae-8e133-default-rtdb.firebaseio.com"
  };
  try{firebase.initializeApp(firebaseConfig)}catch(e){}
  const db=firebase.database();
  const rows=Array(CONFIG.tables).fill(null);
  let groups=[];
  const refTable=(i)=> db.ref('orders/'+CONFIG.ROOM+'/tables/'+i);
  const groupsRef=db.ref('orders/'+CONFIG.ROOM+'/groups');

  const STATE_OFF=0, STATE_ACTIVE=1, STATE_SERVED=2;

  const grid33=document.getElementById('grid33');
  const pgrid =document.getElementById('pgrid');

  const countOrdered=(arr)=>arr.filter(v=>v!==STATE_OFF).length;
  const countServed =(arr)=>arr.filter(v=>v===STATE_SERVED).length;

  function remainingFor(ti,mi){
    const r=rows[ti]; if(!r) return 0;
    const ordered=countOrdered(r.menu?.[mi]||[]);
    const served =countServed (r.menu?.[mi]||[]);
    return Math.max(0,ordered-served);
  }
  const headOf=(i)=>rows[i]?.head!=null? rows[i].head: i;
  const getGroup=(gid)=>(groups||[]).find(x=>x&&x.id===gid)||null;
  const membersOfHead=(hi)=> rows[hi]?.groupId? (getGroup(rows[hi].groupId)?.members||[]):[hi];

  function aggForHead(hi){
    const mem=membersOfHead(hi);
    const fo=Math.min(...mem.map(m=>rows[m]?.firstOrderedAt??Infinity));
    const fs=Math.min(...mem.map(m=>rows[m]?.firstServedAt??Infinity));
    return {mem, fo:isFinite(fo)?fo:null, fs:isFinite(fs)?fs:null};
  }

  // manage와 동일한 상태색 판단
  function rowAnyOrdered(r){
    const m=(r.menu||[]).some(c=>c.some(v=>v!==STATE_OFF));
    const b=(r.bev?.COLA?.qty + r.bev?.CIDER?.qty + r.bev?.ZERO?.qty)>0;
    return m||b;
  }
  function rowAllServed(r){
    const menusDone=(r.menu||[]).every(c=> countOrdered(c)===countServed(c));
    const bevsDone=(["COLA","CIDER","ZERO"].every(k=> (r.bev?.[k]?.qty||0)===0 || !!(r.bev?.[k]?.served)));
    return menusDone && bevsDone && rowAnyOrdered(r);
  }
  function stateClass(r){
    if(r?.call) return 'row-orange';
    if(r?.math) return 'row-pink';
    if(rowAllServed(r) || r?.done) return 'row-green';
    const ts = r?.timeStamp || r?.firstServedAt;
    const yellow = (r?.people>0 || rowAnyOrdered(r)) && !ts;
    if(ts){
      const elapsed = Date.now()-ts;
      const remain  = (ts + 90*60*1000) - Date.now();
      if(remain<=10*60*1000) return 'row-red';
      if(elapsed>=50*60*1000) return 'row-gray';
      return 'row-blue';
    }
    if(yellow) return 'row-yellow';
    return '';
  }

  /* ===== 다음 나갈 테이블(음식) — 남은 수량 포함(표시는 1개만) ===== */
  function nextTableForMenu(mi){
    const heads=[...new Set(rows.map((_,i)=>headOf(i)))].sort((a,b)=>a-b);
    const headRemain=(h)=> membersOfHead(h).reduce((s,m)=>s+remainingFor(m,mi),0);
    let cand=heads.filter(h=>headRemain(h)>0).map(h=>({h,...aggForHead(h)}));
    if(!cand.length) return null;
    let pool=cand.filter(c=>!c.fs); if(!pool.length) pool=cand;
    pool.sort((a,b)=>(a.fo??Infinity)-(b.fo??Infinity));
    const chosen=pool[0];
    const memberIdx=chosen.mem.find(m=>remainingFor(m,mi)>0);
    if(memberIdx==null) return null;
    const remain=remainingFor(memberIdx,mi);
    return {member:memberIdx, tableNo:memberIdx+1, remain};
  }

  /* ===== 다음 나갈 테이블(음료: qty>0) — 잔여 수량 포함 ===== */
  const BEV_KEYS=[["COLA","콜라"],["CIDER","사이다"],["ZERO","제로콜라"]];
  function nextTableForBeverage(bi){
    const key=BEV_KEYS[bi][0];
    const heads=[...new Set(rows.map((_,i)=>headOf(i)))].sort((a,b)=>a-b);
    const headRemain=(h)=> membersOfHead(h).reduce((s,m)=> s + (rows[m]?.bev?.[key]?.qty||0), 0);
    let cand=heads.filter(h=>headRemain(h)>0).map(h=>({h,...aggForHead(h)}));
    if(!cand.length) return null;
    let pool=cand.filter(c=>!c.fs); if(!pool.length) pool=cand;
    pool.sort((a,b)=>(a.fo??Infinity)-(b.fo??Infinity));
    const chosen=pool[0];
    const memberIdx=chosen.mem.find(m=> (rows[m]?.bev?.[key]?.qty||0) > 0 );
    if(memberIdx==null) return null;
    const qty = rows[memberIdx]?.bev?.[key]?.qty || 0;
    return {member:memberIdx, tableNo:memberIdx+1, key, qty};
  }

  /* ===== (추가) 서빙 처리(메뉴 1개) — 메뉴로만 타이머 시작 ===== */
  function markMenuOne(tableIdx, menuIdx){
    const r=rows[tableIdx]; if(!r) return;
    const states=(r.menu?.[menuIdx]||[]);
    const k=states.findIndex(v=>v===STATE_ACTIVE);
    if(k===-1) return;
    states[k]=STATE_SERVED;

    if(!r.firstServedAt){
      const ts=Date.now();
      if(r.groupId){
        const mem = membersOfHead(headOf(tableIdx));
        mem.forEach(mi=> refTable(mi).update({menu:rows[mi].menu, firstServedAt:ts}) );
      }else{
        refTable(tableIdx).update({menu:r.menu, firstServedAt:ts});
      }
    }else{
      refTable(tableIdx).update({menu:r.menu});
    }
  }

  /* ===== 서빙 처리(음료 일괄 n개) — 타이머 절대 변경 X ===== */
  function markBeverageBatch(tableIdx, bi, n){
    const key=BEV_KEYS[bi][0];
    const r=rows[tableIdx]; if(!r || !r.bev || !r.bev[key]) return;
    const cur = r.bev[key].qty||0;
    const use = Math.max(0, Math.min(cur, n));
    if(use===0) return;
    r.bev[key].qty = cur - use;
    r.bev[key].served = (r.bev[key].qty===0);
    refTable(tableIdx).update({bev:r.bev});
  }

  /* ===== 3x3 타일 렌더 ===== */
  function renderTiles(){
    grid33.innerHTML='';
    const layout = [
      {type:'menu', name:CONFIG.menus[0], mi:0},
      {type:'menu', name:CONFIG.menus[1], mi:1},
      {type:'bev' , name:BEV_KEYS[0][1], bi:0},
      {type:'menu', name:CONFIG.menus[2], mi:2},
      {type:'menu', name:CONFIG.menus[3], mi:3},
      {type:'bev' , name:BEV_KEYS[1][1], bi:1},
      {type:'menu', name:CONFIG.menus[4], mi:4},
      {type:'menu', name:CONFIG.menus[5], mi:5},
      {type:'bev' , name:BEV_KEYS[2][1], bi:2},
    ];

    layout.forEach(item=>{
      const tile=document.createElement('div'); tile.className='tile';
      const name=document.createElement('div'); name.className='name'; name.textContent=item.name;
      const next=document.createElement('div'); next.className='next';

      let info=null, clickable=false, confirmText='', onDo=null, hintText='';

      if(item.type==='menu'){
        info = nextTableForMenu(item.mi);
        next.textContent = info? (info.tableNo+'테이블') : '—';       // 화면 표시: 테이블 번호만
        clickable = !!info;
        confirmText = info ? `[확인]\n${item.name} 1개 → ${info.tableNo}번 테이블에 지금 나가겠습니까?` : '';
        onDo = ()=> info && markMenuOne(info.member, item.mi);        // 1개만 처리
        hintText = clickable? '탭하여 서빙 처리' : '대기 없음';
      }else{
        info = nextTableForBeverage(item.bi);
        next.textContent = info? (info.tableNo+'테이블 × '+info.qty) : '—'; // 음료는 일괄 표기 유지
        clickable = !!info;
        confirmText = info ? `[확인]\n${item.name} ${info.qty}개 → ${info.tableNo}번 테이블에 지금 나가겠습니까?` : '';
        onDo = ()=> info && markBeverageBatch(info.member, item.bi, info.qty);
        hintText = clickable? '탭하여 서빙 처리(일괄)' : '대기 없음';
      }

      const hint=document.createElement('div'); hint.className='hint';
      hint.textContent = hintText;

      if(!clickable) tile.classList.add('disabled');

      tile.onclick=()=>{
        if(!clickable) return;
        if(confirm(confirmText)) onDo();
      };

      tile.appendChild(name);
      tile.appendChild(next);
      tile.appendChild(hint);
      grid33.appendChild(tile);
    });
  }

  /* ===== 인원 현황 ===== */
  function renderPeople(){
    pgrid.innerHTML="";
    for(let i=0;i<CONFIG.tables;i++){
      const r=rows[i]||{};
      const cell=document.createElement('div'); 
      const cls=stateClass(r);
      cell.className='cell'+(cls?(' '+cls):'');
      const t=document.createElement('div'); t.className='t'; t.textContent=(i+1)+'번';
      const p=document.createElement('div'); p.className='p'; p.textContent=String(r.people||0);
      cell.appendChild(t); cell.appendChild(p);
      pgrid.appendChild(cell);
    }
  }

  /* ===== 구독 ===== */
  for(let i=0;i<CONFIG.tables;i++){
    refTable(i).on('value',s=>{
      rows[i]=s.val()||{};
      renderTiles(); renderPeople();
    });
  }
  groupsRef.on('value',s=>{groups=s.val()||[]; renderTiles();});
})();
</script>
</body>
</html>
